import bpy
from bpy.props import StringProperty, IntProperty
from datetime import datetime, timezone


def textBox(self, sentence, icon='NONE', line=56):
	layout = self.box().column()
	if sentence.startswith('LINK:'):
		url, name = sentence.split('|')
		url = url.split('LINK:', maxsplit=1)[1]
		name = name.split('NAME:', maxsplit=1)[1]
		layout.row().operator('wm.url_open', text=name, icon='URL').url = url
		return None
	sentence = sentence.split(' ')
	mix = sentence.pop(0)
	if sentence == []:
		layout.row().label(text=mix, icon=icon)
		return None
	broken = False
	while True:
		add = ' ' + sentence[0]
		if len(mix + add) < line:
			mix += add
			sentence.pop(0)
			if sentence == []:
				layout.row().label(text=mix, icon='NONE' if broken else icon)
				return None

		else:
			layout.row().label(text=mix, icon='NONE' if broken else icon)
			broken = True
			mix = sentence[0]
			sentence.pop(0)
			if sentence == []:
				layout.row().label(text=mix)
				return None


class generictext(bpy.types.Operator):
	text: StringProperty(default='')
	icons: StringProperty()
	size: StringProperty()
	width: IntProperty(default=400)
	url: StringProperty(default='')


def format_time(timestamp):
	# This logic was generated by ChatGPT
	date = datetime.strptime(timestamp, '%Y-%m-%dT%H:%M:%SZ')
	date = date.replace(tzinfo=timezone.utc)
	return date.timestamp()


def time_to_calendar(timestamp):
	dt = datetime.fromtimestamp(timestamp)  # local time
	return dt.strftime('%Y-%m-%d %H:%M')


def download_file(url, folder):
	import requests
	import os
	# Replace with the actual URL

	output_filename = url.split('/')[-1]
	output_path = os.path.join(folder, output_filename)

	try:
		response = requests.get(url, stream=True)
		response.raise_for_status()  # Raise an exception for bad status codes

		with open(output_path, 'wb') as f:
			for chunk in response.iter_content(chunk_size=8192):
				f.write(chunk)

	except requests.exceptions.RequestException as e:
		print(f'Error downloading file: {e}')


def play_sound(path, volume=1.0):
	import os

	if not os.path.exists(path):
		return
	import aud

	dev = aud.Device()
	sound = aud.Sound(path)
	dev.volume = volume
	dev.play(sound)


def operator_report(r_type, r_message):
	def sub_report_function():
		bpy.ops.emb.quick_report('INVOKE_DEFAULT', r_type=r_type, r_message=r_message)

	bpy.app.timers.register(sub_report_function)
